# -*- coding: utf-8 -*-
"""Taller_n_22.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19EmvJSCfHqnvYcm8WeaGqK_irBdHxs4k
"""

import random
import sys

class BSTNode:
    def __init__(self, value: int):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def add(self, value: int):
        if self.root is None:
            self.root = BSTNode(value)
            return True
        else:
            return self._add_recursive(self.root, value)

    def _add_recursive(self, node: BSTNode, value: int):
        if value == node.value:
            return False
        elif value < node.value:
            if node.left is None:
                node.left = BSTNode(value)
                return True
            else:
                return self._add_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = BSTNode(value)
                return True
            else:
                return self._add_recursive(node.right, value)

    def contains(self, value: int) -> bool:
        """Determina si el árbol contiene el valor (búsqueda binaria en BST)."""
        current = self.root
        while current is not None:
            if value == current.value:
                return True
            elif value < current.value:
                current = current.left
            else:
                current = current.right
        return False

    def inorder(self):
        """Devuelve una lista con los elementos en orden ascendente (recorrido in-order)."""
        res = []
        self._inorder_recursive(self.root, res)
        return res

    def _inorder_recursive(self, node: BSTNode, res: list):
        if node is None:
            return
        self._inorder_recursive(node.left, res)
        res.append(node.value)
        self._inorder_recursive(node.right, res)

def generar_numeros_unicos(cantidad=20, minimo=1, maximo=100):
    """Genera 'cantidad' números enteros únicos entre minimo y maximo inclusive."""
    if cantidad > (maximo - minimo + 1):
        raise ValueError("Rango demasiado pequeño para generar valores únicos.")
    return random.sample(range(minimo, maximo + 1), cantidad)

def menu_interactivo(bst: BinarySearchTree, numeros_generados: list):
    while True:
        print("\n--- Menú Taller 22 (Árbol de Búsqueda Binaria) ---")
        print("1) Buscar un número en el árbol")
        print("2) Imprimir elementos del árbol en forma ascendente")
        print("3) Mostrar los 20 números generados (sin ordenar)")
        print("4) Salir")
        opcion = input("Seleccione una opción (1-4): ").strip()

        if opcion == "1":
            entrada = input("Ingrese el número a buscar: ").strip()
            if not entrada.lstrip('-').isdigit():
                print("Por favor ingrese un número entero válido.")
                continue
            valor = int(entrada)
            encontrado = bst.contains(valor)
            if encontrado:
                print(f"El número {valor} SÍ se encuentra en el árbol.")
            else:
                print(f"El número {valor} NO se encuentra en el árbol.")
        elif opcion == "2":
            ordenados = bst.inorder()
            print("Elementos del árbol en orden ascendente:")
            print(ordenados)
        elif opcion == "3":
            print("Números generados (orden de generación):")
            print(numeros_generados)
        elif opcion == "4":
            print("Saliendo. ¡Hasta luego!")
            break
        else:
            print("Opción inválida. Intente nuevamente.")

def main():
    numeros = generar_numeros_unicos(20, 1, 100)
    print("Se han generado 20 números aleatorios únicos entre 1 y 100.")
    bst = BinarySearchTree()
    for n in numeros:
        bst.add(n)

    print("Números generados (sin ordenar):")
    print(numeros)
    print("Número de nodos insertados en el árbol:", len(bst.inorder()))

    menu_interactivo(bst, numeros)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupción por teclado. Saliendo.")
        sys.exit(0)